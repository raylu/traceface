#!/usr/bin/env python3

import argparse
import copy
import importlib
import sys
import traceback

import jinja2

def main():
	parser = argparse.ArgumentParser()
	parser.add_argument('code', metavar='CODE', type=str)
	parser.add_argument('-i', dest='module', type=str)
	args = parser.parse_args()

	run_globals = None
	if args.module is not None:
		module = importlib.import_module(args.module)
		run_globals = {args.module: module}
	tracer = Tracer()
	try:
		tracer.run(args.code, run_globals)
	except:
		traceback.print_exc()
	tracer.handle_last()

	trace = tracer.trace
	for frame in trace:
		frame.render()

	with open('template.jinja2', 'r') as f:
		template = jinja2.Template(f.read())
	with open('trace.html', 'w') as f:
		stream = template.stream({'trace': trace})
		stream.enable_buffering()
		stream.dump(f)

class Tracer:
	def __init__(self):
		self.trace = []
		self.bottom_frame = None
		self.last_frame = None

	def run(self, code, run_globals=None):
		sys.settrace(self.trace_dispatch)
		try:
			exec(code, run_globals)
		finally:
			sys.settrace(None)

	def trace_dispatch(self, frame, event, arg):
		if event == 'call':
			self.handle_call(frame)
		elif event == 'exception':
			self.handle_exception(frame)
		return self.trace_dispatch

	def handle_call(self, frame):
		if self.bottom_frame is None:
			self.bottom_frame = frame
		elif frame.f_back is not self.bottom_frame: # skip the first 2 frames
			self._add_trace(frame.f_back)
			self.last_frame = frame

	def handle_exception(self, frame):
		if frame is not self.bottom_frame:
			self._add_trace(frame)
		self.last_frame = None

	def handle_last(self):
		if self.last_frame is not None:
			self._add_trace(self.last_frame, True)

	def _add_trace(self, frame, last=False):
		local_vars = frame.f_locals
		code = frame.f_code
		if last:
			lineno = code.co_firstlineno
		else:
			lineno = frame.f_lineno
		depth = -1
		while frame is not None and frame is not self.bottom_frame:
			frame = frame.f_back
			depth += 1
		frame_obj = Frame(code.co_filename, code.co_name, lineno, depth, local_vars)
		self.trace.append(frame_obj)

class Frame:
	files = {}

	def __init__(self, filepath, func_name, line_no, depth, local_vars):
		self.filepath = filepath
		self.func_name = func_name
		self.line_no = line_no
		self.depth = depth
		self.local_vars = {k: repr(v) for k, v in local_vars.items()}

		self.rendered = None

	def render(self):
		if self.filepath[0] == '<':
			return
		lines = self.files.get(self.filepath)
		if lines is None:
			with open(self.filepath, 'r') as f:
				lines = self.files[self.filepath] = f.readlines()
		start = max(self.line_no - 4, 0)
		context = copy.copy(lines[start:self.line_no + 3])
		index = self.line_no - start - 1
		context[index] = '<span class="highlight">%s</span>' % context[index]
		self.rendered = ''.join(context)

	def __repr__(self):
		return '%s(%r, %r, %r, %r)' % (self.__class__.__name__,
				self.filepath, self.func_name, self.line_no, self.depth)

if __name__ == '__main__':
	main()
